\subsection{Pruebas unitarias}
\label{ss:unit-tests}
El nivel de pruebas de unidad se enfoca en cada componente de forma individual o clases de objetos, lo que garantiza que funcione debidamente como unidad, de ahí su nombre. Estas pruebas deben enfocarse en comprobar la funcionalidad de objetos o métodos \citep{sommerville2011software}. \ac{xp} plantea la realización de pruebas unitarias continuas, frecuentemente repetidas y automatizadas, incluyendo pruebas de regresión, y aconseja escribir el código de la prueba antes de la codificación \citep{kniberg2007scrumyxp}.\\
\subsubsection*{Pruebas automatizadas}
Las pruebas automatizadas se han convertido en una de las técnicas más adoptadas en el proceso de pruebas de software, ayuda a acelerar el lanzamiento al mercado al tiempo que proporciona amplio margen para que los profesionales de las pruebas trabajen en la búsqueda de casos de prueba críticos. Estas pruebas no solo mejoran la confiabilidad de su aplicación, sino que también aceleran el proceso de prueba, mejoran la cobertura de prueba y brindan confianza a los evaluadores para una prueba de mejor calidad del producto \citep{acanda2018cdis}.
Para la aplicación de las pruebas unitarias a la solución se empleó el marco JUnit el cual permite realizar la ejecución de clases Java de manera controlada, para poder evaluar si el funcionamiento de cada uno de los métodos de la clase se comporta como se espera. Es decir, en función de algún valor de entrada se evalúa el valor de retorno esperado; si la clase cumple con la especificación, entonces JUnit devolverá que el método de la clase pasó exitosamente la prueba; en caso de que el valor esperado sea diferente al que regresó el método durante la ejecución, JUnit devolverá un fallo en el método correspondiente.
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/test/PU1.jpg}
	\caption{Resultado de la ejecución de pruebas unitarias en el código fuente de la solución. Parte 1.}
	\label{fig:pu1}
\end{figure}
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/test/PU2.jpg}
	\caption{Resultado de la ejecución de pruebas unitarias en el código fuente de la solución. Parte 2.}
\end{figure}

Se realizaron 39 pruebas unitarias al código de las cuales 8 fueron
fallidas y se corrigieron exitosamente. A continuación, en la figura \ref{fig:before-error}, se muestra el un fragmento de código en el estado previo a la corrección de uno de los errores detectados:

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/test/before-error.jpg}
	\caption{Método crearComisión con error}
	\label{fig:before-error}
\end{figure}

Como se puede apreciar se está intentando crear una comisión, pero la lógica del código no fue bien planteada y se terminón recibiendo una excepción ya que para crear una comisión
disciplinaria se hace necesario asignarle una resolución que la contenga. La solución a dicho problema se encuentra en la siguiente figura \ref{fig:after-error}:
\clearpage
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/test/after-error.jpg}
	\caption{Método crearComisión corregido}
	\label{fig:after-error}
\end{figure}

De esta forma garantizamos que una resolución contiene la comisión que
estamos creando y esta se puede guardar con normalidad en la base de
datos.

Ahora se mostrarán algunas imágenes de otras pruebas exitosas:\\

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/test/E1.jpg}
	\caption{prueba para crearResolución()}
\end{figure}

Se hace una prueba para crearResolución(): Se comprueba que la
creación de una resolución sea exitosa después de asignarle una comisión
disciplinaria.

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/test/E2.jpg}
	\caption{prueba para modificarResolucion()}
\end{figure}

Se hace una prueba para modificarResolucion(): Se actualiza la
información de una resolución ya creada buscando fallas

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/test/E3.jpg}
	\caption{prueba para listarResolucion()}
\end{figure}

Se hace una prueba para listarResolucion(): Se llaman objetos
de la base de datos para guardarlos en un listado de objetos
de tipo: Resolucion

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/test/E4.jpg}
	\caption{prueba para modificarComision()}
\end{figure}

Se hace una prueba para modificarComision(): Se actualiza la
información de una comisión seleccionada buscando fallas

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/test/E5.jpg}
	\caption{prueba para mostrarComisionl()}
\end{figure}

Se hace una prueba para mostrarComisionl(): Se llama a la
base de datos para obtener objetos de tipo: Comision

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/test/E6.jpg}
	\caption{prueba para crearDenuncia()}
\end{figure}

Se hace una prueba para crearDenuncia(): Se crea una denuncia,
este es uno de los métodos más importantes y base de la aplicación

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/test/E7.jpg}
	\caption{prueba para mostrarUsuarios()}
\end{figure}

Se hace una prueba para mostrarUsuarios(): Se comprueba que todos
los usuarios se muestren correctamente

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/test/E8.jpg}
	\caption{prueba para modificarRol()}
\end{figure}

se hace un test para modificarRol(): Se comprueba el correcto
funcionamiento en la actualización de los atributos del objeto de prueba de tipo: Rol
