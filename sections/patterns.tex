\section{Patrones de diseño}
Un patrón de diseño es una abstracción de una solución en un nivel alto. Los patrones solucionan problemas que existen en muchos niveles de abstracción. Hay patrones que abarcan las distintas etapas del desarrollo \citep{giraldo2011disenosoft}.

\subsection{Patrones GRASP} Lo esencial de un diseño de objetos lo constituye el diseño de las interacciones de objetos y la asignación de responsabilidades. Las decisiones que se tomen pueden influir profundamente en la extensibilidad, claridad y mantenimiento del sistema de software de objetos, además en el grado y calidad de los componentes reutilizables, por esta razón, durante el diseño se deben realizar los casos de usos con objetos basado en los \ac{grasp} \citep{giraldo2011disenosoft}.
Algunos ejemplos de patrones \ac{grasp} utilizados en la implementación de la solución son los siguientes.

\paragraph{Creador:}

Este patrón implica que un objeto debe responsabilizarse de crear otros:
\begin{itemize}
    \item Si contiene o agrega varios objetos del tipo de los creados.
    \item Si se encarga de registrar objetos del tipo de los creados.
    \item Si utiliza mucho los objetos creados.
    \item O si contiene los datos para crear los del tipo creados.
\end{itemize}

Demostración de uso de patrón \textbf{creador:}

\includegraphics[width=0.6\textwidth]{images/patterns/creator.jpg}

En la imagen anterior se demuestra el uso del patrón creador pues la
clase ``CasoService'' hace bastante uso por medio de los métodos que
dispone de los objetos existentes en la base de datos, hace registros de
los mismos con frecuencia y posee los datos necesarios para crear dichos
objetos.

\paragraph{Controlador \emph{(controller)}:}

Es un patrón por el cual definimos objetos llamados controladores que
independizan las interfaces con las acciones que haya que hacer.

Estos controladores tienen que ser lo más pequeños posible y numerosos,
aislando todo lo posible las capas internas de los programas de las
interfaces.

Demostración de uso del patrón \textbf{controlador:}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{images/patterns/controller.jpg}
    \caption{Demostración de uso del patrón controlador}
    \label{fig:controller}
\end{figure}
\includegraphics[width=0.6\textwidth]{images/patterns/controller.jpg}

En la imagen anterior se demuestra el uso del patrón controlador pues la
clase ``CasoController'', entre otras señaladas, independizan las
interfaces con acciones que se deben realizar, además de que separan, en la
medida de lo posible, las capas internas de la programación de la
aplicación de su interfaz.




\subsection{Patrones GoF}
En el año 1994, apareció el libro ``Design Patterns: Elements of Reusable Object Oriented Sofware'' escrito por los ahora famosos \emph{Gang of Four} (Pandilla de los cuatro) integrada por Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides. Estos recopilaron y documentaron 23 patrones de diseño aplicados usualmente por expertos diseñadores de software orientado a objetos. Desde luego ellos no son los inventores ni los únicos involucrados, pero luego de la publicación de ese libro empezó a difundirse con más fuerza la idea de patrones de diseño. Se distinguen tres tipos de patrones GoF: patrones de comportamiento, patrones creacionales y patrones estructurales \citep{giraldo2011disenosoft}.

\paragraph{Patrón único \emph{(singleton)}:}
Garantiza que una clase sólo tenga una instancia, y proporciona un punto de acceso global a ella.\\

Demostración de uso del patrón \textbf{único:}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{images/patterns/autowired.png}
    \caption{Demostración de uso del patrón único}
    \label{fig:singleton}
\end{figure}
En la imagen se muestra como se inyecta una instancia única de varios objetos que se podrán usar en una clase controladora para tenerlos como punto de acceso global a ella.
\subsubsection{Patrones creacionales:} Tratan con las formas de crear instancias de objetos. El objetivo de estos patrones es de abstraer el proceso de instanciación y ocultar los detalles de cómo los objetos son creados o inicializados.
\paragraph{ Adapter:} Adapta una interfaz para que pueda ser utilizada por una clase que de otro modo no podría utilizarla.
\paragraph{ Bridge:} Desacopla una abstracción de su implementación.
\paragraph{ Compositive:}  Permite tratar objetos compuestos como si se tratara de uno simple.
\paragraph{ Decorator:} Añade funcionalidad a una clase dinámicamente.
\paragraph{ Facade:} Provee de una interfaz unificada simple para acceder a una interfaz o grupo de interfaces de un subsistema.
\paragraph{ Flyweigth:}  Reduce la redundancia cuando gran cantidad de objetos poseen idéntica información.
\paragraph{ Proxy:} Mantiene un representante de un objeto.

\subsubsection*{Patrones estructurales:} Describen cómo clases y objetos pueden ser combinados para formar grandes estructuras y proporcionar nuevas funcionalidades. Estos objetos adicionados pueden ser incluso objetos simples u objetos compuestos.
\paragraph{ Chain of responsability:} Permite establecer la línea que deben llevar los mensajes para que los objetos realicen la tarea indicada.
\paragraph{ Command:} Permite encapsular una operación en un objeto, permitiendo ejecutar dicha operación sin necesidad de conocer el contenido de la misma.
\paragraph{ Interpreter:}  Dado un lenguaje, define una gramática para dicho lenguaje, así como las herramientas necesarias para interpretarlo.
\paragraph{ Iterator:}  Proporciona un modo de acceder secuencialmente a los elementos de un objeto agregado sin exponer su representación interna.
\paragraph{ Mediator:}  Define un objeto para encapsular la interacción en un conjunto de objetos. Promueve un bajo acoplamiento al evitar que los objetos se refieran unos a otros explícitamente, y permite variar la interacción entre ellos de forma independiente.
\paragraph{ Memento:}  Representa y externaliza el estado interno de un objeto sin violar la encapsulación, de forma que éste puede volver a dicho estado más tarde.
\paragraph{ Observer:}  Define una dependencia de uno-a-muchos entre objetos, de forma que cuando un objeto cambie de estado se notifique y actualicen automáticamente todos los objetos que dependen de él.
\paragraph{ State:} Permite que un objeto modifique su comportamiento cada vez que cambia su estado interno. Parecerá que cambia la clase del objeto.
\paragraph{ Strategy:} Define una familia de algoritmos, encapsula uno de ellos y los hace intercambiables. Permite que un algoritmo varíe independientemente de los clientes que lo usan.
\paragraph{ Template Method:} Define en una operación el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Permite que las subclases redefinan ciertos pasos del algoritmo sin cambiar su estructura.
\paragraph{ Visitor:} Representa una operación sobre los elementos de una estructura de objetos. Permite definir una nueva operación sin cambiar las clases de los elementos sobre los que opera.