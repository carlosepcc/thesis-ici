\section{Herramientas y tecnologías a utilizar}

Para el desarrollo de cualquier aplicación, es necesario utilizar diferentes técnicas como: los patrones de diseño o las metodologías de desarrollo de software, además del uso de distintas herramientas como los compiladores o editores de códigos. Aunque a simple vista parezca que la selección de las tecnologías para desarrollar aplicaciones es fácil, es totalmente lo contrario; para su correcta selección, es necesario ver el problema a resolver desde diferentes ángulos y posibles situaciones futuras. El presente epígrafe aborda alguna de las diferentes herramientas que dan solución a la problemática planteada.

\subsection{Patrones de diseño: }

Según el libro Dive Into Design Patterns, los patrones de diseño son:
\begin{quote}
	``Soluciones típicas a problemas comunes en el desarrollo de software. Se podría decir que son como planos predefinidos que pueden ser adaptados para resolver problemas en el diseño de la codificación de un programa~\citep{Shevts2019}.''
\end{quote}

Normalmente se confunden con algoritmos, porque ambos conceptos describen soluciones típicas a problemas conocidos, mientras que un algoritmo describe una serie de pasos a seguir para lograr un objetivo, un patrón es una descripción de alto nivel de la solución, o sea, la codificación de un mismo patrón puede ser diferente en programas distintos~\citep{Shevts2019}.

Los patrones de diseño difieren entre ellos debido a su complejidad, el nivel de detalles necesarios y la escala del sistema que se va a implementar. Los patrones de bajo nivel son llamados idiomas y usualmente solo se aplican a un lenguaje de programación. Mientras que los patrones más universales y de más alto nivel, son llamados patrones arquitectónicos. Estos últimos pueden ser usados en cualquier programa independiente del lenguaje en que sea programado y además pueden ser utilizados para crear la arquitectura completa de un software~\citep{Shevts2019}. 

\subsubsection{Surgimiento de los patrones:}

En un principio, no fueron llamados patrones, ni estaban agrupados, sino que fueron soluciones que se repitieron una y otra vez en el desarrollo de software. Debido a esto, Erich Gamma, Jhon Vlissides, Ralph Johnson y Richard Helm en 1995 escribieron el libro ``Design Patterns: Elements of Reusable Object-Oriented software'', libro que reunía y clasificaba las soluciones hasta ahora utilizadas. 

El concepto de patrón se dió a conocer en el libro ``Pattern Language: Towns, Buildings, Construction'' del autor Christopher Alexander, donde se describía un lenguaje natural para la construcción de edificios. Teniendo el libro anteriormente mencionado como base, fue que estas soluciones a problemas repetitivos fueron nombradas como patrones de diseño de programación.

Con el tiempo, estas cuatro personas pasaron a llamarse Gang of Four (Banda de los cuatro) y a su vez el nombre del libro paso a ser ``The GOF book''.

\subsubsection{Tipos de patrones}
En total el libro recoge 23 patrones, divididos en tres categorías según su intención:
\begin{itemize}
	\item Patrones Creacionales:
	\begin{itemize}
		\item Provee mecanismos para la creación de objetos lo que incrementa la flexibilidad y la reutilización de código existente.
	\end{itemize}
	\item Patrones Estructurales:
	\begin{itemize}
		\item Explica como ensamblar objetos y clases dentro de largas estructuras, mientras que la estructura se mantiene flexible y eficiente.
	\end{itemize}
	\item Patrones de Comportamiento:
	\begin{itemize}
		\item Se encarga de la comunicación eficiente y la asignación de responsabilidades entre los objetos.
	\end{itemize}
\end{itemize}

\subsection{Metodologías para el desarrollo de software:}

``Los softwares han sido parte de la vida cotidiana de la humanidad desde hace muchos años, pero su desarrollo comenzó de una manera muy desorganizada, ya que se basaba en actividades de codificar y arreglar los errores. Los softwares en su mayoría eran creados sin seguir una línea de actividades, por lo que la estructura de estos podía variar frecuentemente. Pero como todo en la vida, llega un momento en que hay que organizar la forma en que se hacen las cosas, por lo que surgió una alternativa llamada metodología. Esta dictaba un proceso bien estructurado para la creación de software, lo cual hacía el desarrollo de estos más predictibles y eficientes''~\citep{Awad2005}.

Primero surgieron las metodologías tradicionales poseedoras un plan de trabajo extenso, debido a la documentación de los requerimientos del software, seguidos por la especificación de la arquitectura y una representación de alto nivel del software a desarrollar. Debido a la cantidad de trabajo a realizar, las metodologías tradicionales pasaron a ser conocidas como metodologías pesadas. Mayormente se utilizaban en software con un alto impacto, ya sea para la vida o la sociedad. Pero los proyectos que no poseían un impacto tan notable, también debían utilizar las metodologías pesadas, por lo que el trabajo era muy lento y lleno de dificultades~\citep{Awad2005}.

En respuesta al trabajo excesivo y minucioso en proyectos sin grandes repercusiones en la sociedad, nacieron las metodologías ágiles, que fueron destinadas al desarrollo de software mediante la interacción con el cliente. Cambios en la estructura del proyecto de forma más seguida y un desarrollo rápido, eran las características que más diferían del propósito principal de las metodologías pesadas.


La siguiente tabla explica de forma resumida las diferencias que existen entre las metodologías ágiles y las pesadas:

\input{../tables/methodologies-comparison.tex}

Como se vio anteriormente las metodologías se dividen en dos tipos, las metodologías ágiles y las tradicionales, dentro de las últimas podemos encontrar:
\begin{itemize}
	\item Waterfall:
	\begin{itemize}
		\item En español Cascada.
		\item Hace énfasis en una estructura progresiva entre diferentes fases del desarrollo del software. Cada fase contiene un conjunto de actividades definidas, por lo que deben ser cumplidas antes de pasar a la siguiente fase.
	\end{itemize}
	\item \ac{RUP}:
	\begin{itemize}
		\item También conocida como Proceso Unificado de Rational.
		\item Organiza el desarrollo en flujo de trabajos y son realizados de forma iterativa e incremental.
	\end{itemize}
\end{itemize}

Dentro de las metodologías ágiles están:
\begin{itemize}
	\item \ac{XP}
	\begin{itemize}
		\item Programación Extrema.
		\item Se caracteriza por los ciclos de desarrollo cortos, el incremento de los planes para el desarrollo del software, además de la retroalimentación que se establece con el cliente.
	\end{itemize}
	\item SCRUM:
	\begin{itemize}
		\item Describe la forma en que los miembros de equipo deben trabajar para poder obtener un sistema flexible en un entorno que varía de manera constante.
	\end{itemize}
	\item Agile Lite:
	\begin{itemize}
		\item ``(...)puede ser aplicada a cualquier proyecto, asumiendo que el trabajo a realizar se pueda dividir en pequeñas acciones.''~\citep{AgileLiteHumanos}
		\item Utiliza ciclos de desarrollos cortos.
	\end{itemize}
\end{itemize}

Con la ayuda de la información anteriormente expuesta, ya es hora de seleccionar una metodología para el desarrollo del \cdis, pero antes, se deben poner en una balanza las características del proyecto a desarrollar. El uso de la tabla anteriormente descrita \ref{tab:metodologias}, es de vital importancia para una correcta selección de la metodología a utlizar. Una vez balanceada, según las necesidades requeridas para desarrollar el \cdis, esta ``guía'' toma la siguiente estructura:


% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[h]
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		\rowcolor[HTML]{C4BBD7} 
		{ } & { Ágiles} & { Pesadas} \\ \hline
		Acercamiento & X &  \\ \hline
		\stripe 
		Medición del objetivo & X &  \\ \hline
		Tamaño del proyecto & X &  \\ \hline
		\stripe 
		Tipo de administración & X &  \\ \hline
		Perspectiva de cambios & X &  \\ \hline
		\stripe 
		Cultura del equipo & X &  \\ \hline
		Documentación & X &  \\ \hline
		\stripe 
		Orientada & X &  \\ \hline
		Ciclos de desarrollo & X &  \\ \hline
		\stripe 
		Dominio de desarrollo &  & X \\ \hline
		Planificación inicial & X &  \\ \hline
		\stripe 
		Retorno de la inversión &  & X \\ \hline
		Tamaño del equipo & X &  \\ \hline
		\stripe 
		Total: & 11 & 2 \\ \hline
	\end{tabular}
	\caption{Resultado de la selección de la metodología}
	\label{tab:resultado}
\end{table}

Según la tabla anterior, el software debe ser desarrollado siguiendo las pautas de las metodologías ágiles, ya que cumple 11 de los 13 parámetros necesarios para tomar la decisión.

Dentro de las posibles metodologías ágiles a seleccionar se encuentras: \ac{XP}, Scrum, Agile Lite. Se decide utilizar \ac{XP}.

\subsubsection{Programación Extrema:}

``Es una Metodología ligera de desarrollo de aplicaciones que se basa en la simplicidad, la comunicación y la realimentación del código desarrollado''~\citep{VALLADAREZ2016}.

Objetivos de \ac{XP}:
\begin{itemize}
	\item La satisfacción del cliente.
	\item Potenciar el trabajo en equipo.
	\item Minimizar el riesgo actuando sobre las variables del proyecto: costo, tiempo, calidad, alcance.
\end{itemize}

Características:
\begin{itemize}
	\item Metodología basada en prueba y error para obtener un software que funcione correctamente.
	\item Es orientada hacia quien produce y usa el software.
	\item Reduce el costo de cambio en todas las etapas del ciclo de vida de la aplicación.
	\item Cliente bien definido.
	\item Los requisitos pueden cambiar.
\end{itemize}

\textbf{Artefactos de la metodología \ac{XP}:}

\textbf{Historia de usuarios:}

Las \ac{HU} representan una breve descripción del comportamiento del sistema. Se realizan por cada característica principal del sistema y son utilizadas para cumplir estimaciones de tiempo y el plan de lanzamientos, así mismo reemplazan un gran documento de requisitos y presiden la creación de las pruebas de aceptación~\citep{VALLADAREZ2016}..

Cada \ac{HU} debe ser lo suficientemente comprensible y delimitada para que los programadores puedan implementarlas en unas semanas.



\textbf{Tareas de ingeniería:}

Una \ac{HU} se descompone en varias tareas de ingeniería, que describen las actividades que se realizarán en cada \ac{HU}, así mismo las tareas de ingeniería se vinculan más al desarrollador, ya que permite tener un acercamiento con el código~\citep{VALLADAREZ2016}.. 

%Esta puede ser vista en la tabla \ref{tab:ti}.
%
%\begin{table}[h]
%	\centering
%	\begin{tabular}{|l|l|}
%		\hline
%		\rowcolor[HTML]{C4BBD7} 
%		\multicolumn{2}{|c|}{\cellcolor[HTML]{C4BBD7}{Tarea de Ingeniería}} \\ \hline
%		Número de tarea:  Identificador de la tarea. & \begin{tabular}[|c|]{@{}l@{}}  Número de historia: Número asignado \\ de la historia correspondiente. \end{tabular}\\ \hline
%		\stripe 
%		\multicolumn{2}{|l|}{\cellcolor[HTML]{EDEBF1}Nombre de Tarea: Describe de manera general dicha tarea.} \\ \hline
%		Tipo de tarea: Tipo al que corresponde dicha tarea. & \begin{tabular}[|c|]{@{}l@{}} Puntos estimados: Números de días necesarios \\ para desarrollar dicha tarea. \end{tabular} \\ \hline
%		\stripe 
%		Fecha Inicio: Fecha inicial de la creación de dicha tarea. & Fecha Fin: Fecha de la culminación de dicha tarea. \\ \hline
%		\multicolumn{2}{|l|}{Programador Responsable: Nombre del programador a cargo de desarrollar la tarea.} \\ \hline
%		\stripe 
%		\multicolumn{2}{|l|}{\cellcolor[HTML]{EDEBF1}Descripción: Información detallada de dicha tarea.} \\ \hline
%	\end{tabular}
%	\caption{Plantilla: Tarea de Ingeniería.}
%	\label{tab:ti}
%\end{table}



\textbf{Pruebas de aceptación:}

Antes de conocer en qué consisten las pruebas de aceptación, es necesario conocer los dos tipos de pruebas que  existen, hoy día, en la industria del software~\citep{Nidhra2012}:

\begin{itemize}
	\item \textbf{Caja negra}: Son las pruebas basadas en los requerimientos especificados y no es necesario examinar el código.
	
	\item \textbf{Caja blanca}: Prueba aplicable únicamente sobre el código perteneciente a un software desarrollado. Son diseñados desde el punto de vista del desarrollador. Es principalmente usado para detectar errores lógicos en el código de un programa. 
\end{itemize}

Las pruebas de aceptación pertenecen a la categoría de pruebas de caja negra y son de vital importancia para el éxito de una iteración y el comienzo de la siguiente, con lo cual el cliente puede conocer el avance en el desarrollo del sistema y a los programadores lo que les resta por hacer. Además, permite una retroalimentación para el desarrollo de las próximas historias de usuarios a ser entregadas. Estas son comúnmente llamadas pruebas del cliente, por lo que las realiza el encargado de verificar si las historias de usuarios de cada iteración cumplen con la funcionalidad esperada~\citep{XPACT}. 
%
%Esta plantilla puede ser vista en la tabla \ref{tab:pa}.
%% Please add the following required packages to your document preamble:
%% \usepackage[table,xcdraw]{xcolor}
%% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
%\begin{table}[h]
%	\centering
%	\begin{tabular}{|l|l|}
%		\hline
%		\multicolumn{2}{|c|}{\cellcolor[HTML]{C4BBD7}Prueba de aceptación} \\ \hline
%		\begin{tabular}[c]{@{}l@{}}Código: Nº Único, permite identificar \\ la prueba de aceptación.\end{tabular} & \begin{tabular}[c]{@{}l@{}}Nº Historia de Usuario: Número único \\ que identifica a la historia de usuario.\end{tabular} \\ \hline
%		\multicolumn{2}{|l|}{\cellcolor[HTML]{EDEBF1}\begin{tabular}[c]{@{}l@{}}Historia de Usuario: Nombre que indica de manera general \\ la descripción de la historia de usuario.\end{tabular}} \\ \hline
%		\multicolumn{2}{|l|}{\begin{tabular}[c]{@{}l@{}}Condiciones de Ejecución: Condiciones previas que deben \\ cumplirse para realizar la prueba de aceptación.\end{tabular}} \\ \hline
%		\multicolumn{2}{|l|}{\cellcolor[HTML]{EDEBF1}\begin{tabular}[c]{@{}l@{}}Entrada/Pasos de Ejecución: Pasos que siguen los usuarios \\ para probar la funcionalidad de la historia de usuario.\end{tabular}} \\ \hline
%		\multicolumn{2}{|l|}{\begin{tabular}[c]{@{}l@{}}Resultado Esperado: Respuesta del sistema que el cliente espera, \\ después de haber ejecutado una funcionalidad\end{tabular}} \\ \hline
%		\multicolumn{2}{|l|}{\cellcolor[HTML]{EDEBF1}\begin{tabular}[c]{@{}l@{}}Evaluación de la Prueba: Nivel de satisfacción del cliente sobre \\ la respuesta del sistema. Los niveles son: Aprobada y No Aprobada.\end{tabular}} \\ \hline
%	\end{tabular}
%	\caption{Pruebas de aceptación}
%	\label{tab:pa}
%\end{table}

\textbf{Tarjetas CRC (Clase \textbackslash Responsabilidades \textbackslash Colaboradores)}

Las Tarjetas \ac{CRC}, permiten conocer que clases componen el sistema y cuales interactúan entre sí.
%
%\begin{table}[h]
%	\centering
%	\begin{tabular}{|l|l|}
%		\multicolumn{2}{c}{\cellcolor[HTML]{C4BBD7}{Tarjeta CRC}} \\\hline
%		Nombre de la clase & \begin{tabular}[c]{@{}l@{}}Número de Historia: Número\\   de la historia de usuario correspondiente.\end{tabular} \\\hline
%		\multicolumn{2}{l}{\cellcolor[HTML]{EDEBF1}Responsabilidades: Atributos y operaciones de la clase.} \\ \hline
%	\end{tabular} 
%	\caption{Plantilla: Tarjeta CRC}
%	\label{tab:crc}
%\end{table}
\pagebreak

\textbf{Fases de la programación \ac{XP}:}

\begin{figure}[h]
	\centering
	\includegraphics[width=.6\linewidth]{xp.png}
	\caption{Fases de XP ~\citep{VALLADAREZ2016}.}
	\label{fig:xp}
\end{figure}

\begin{itemize}
	\item \textbf{Planificación}: La Metodología \ac{XP} plantea la planificación como un diálogo continuo entre las partes involucradas en el proyecto, incluyendo al cliente, a los programadores y a los coordinadores. El proyecto comienza recopilando las historias de usuarios, las que constituyen a los tradicionales casos de uso. Una vez obtenidas estas historias de usuarios, los programadores evalúan rápidamente el tiempo de desarrollo de cada una, determinando así el tiempo total de desarrollo del software.
	\item \textbf{Diseño}: Especificación de cómo debe ser el diseño final de la aplicación, haciendo énfasis en que un diseño sencillo es más fácil de implementar que uno complejo.
	\item \textbf{Codificación}: Implementación de los códigos necesarios para satisfacer las historias de usuario.
	\item \textbf{Pruebas}: Una vez terminada la codificación, se deben realizar las pruebas pertinentes a la misma.
\end{itemize}